-- 3rd PHASE
select * from v$version;
show user

-- USE TO TAKE ORIGINAL TABLES BACK
DROP TABLE DOCTOR1;
DROP TABLE VISIT1;
DROP TABLE PATIENT1;
DROP TABLE INSURANCE1;
DROP TABLE VISIT_PROCESS1;
DROP TABLE DIAGNOSIS1;
DROP TABLE SERVICE1;

-- TO BACK UP OUR ORIGINAL TABLES WE ARE GOING TO CREATE 1 EDITION TABLE AS FOLLOWS
CREATE TABLE DOCTOR1 AS SELECT * FROM DOCTOR;
CREATE TABLE VISIT1 AS SELECT * FROM VISIT;
CREATE TABLE PATIENT1 AS SELECT * FROM PATIENT;
CREATE TABLE INSURANCE1 AS SELECT * FROM INSURANCE;
CREATE TABLE VISIT_PROCESS1 AS SELECT * FROM VISIT_PROCESS;
CREATE TABLE DIAGNOSIS1 AS SELECT * FROM DIAGNOSIS;
CREATE TABLE SERVICE1 AS SELECT * FROM SERVICE;



-- 1 AFTER statement trigger (for INSERT, UPDATE and DELETE statements) (among them some table triggers, some row triggers)
-- FOR TABLE AFTER DELETE TRIGGER
SET SERVEROUTPUT ON;
create or replace TRIGGER AD_DOCTOR1_COUNT_DOC
    AFTER DELETE
    ON DOCTOR1
DECLARE
    X INT;
    SAL INT;
    AVERAGE INT;
BEGIN
    SELECT COUNT(ID) INTO X FROM DOCTOR1;
    SELECT SUM(SALARY) INTO SAL FROM DOCTOR1;
    SELECT AVG(SALARY) INTO AVERAGE FROM DOCTOR1;
    DBMS_OUTPUT.PUT_LINE('ONE OF OUR TEAM MEMBER HAS WITHDRAWN:)' || ' NOW WE ARE ' || X || ' PEOPLE'); 
    DBMS_OUTPUT.PUT_LINE('TOTAL SALARY FOR DOCTORS IS ..: ' || SAL || 'PLN AVRERAGE SALARY AMONG ' || X || 'DOCTOR IS ..: ' || AVERAGE || 'PLN');
END;
/
-- DML statements showing how above triggers work 
INSERT INTO DOCTOR1 (ID,NAME,SURNAME,DEPARTMENT,TITLE,EMAIL,PHONE,SALARY,OFF_DAY,COMM) VALUES 
(5,'NAME','SURNAME','DEPT','TITLE','NAME.SURNAME@HOSPITAL.COM','526879898',6000,'MONDAY',NULL);
DELETE FROM DOCTOR1 WHERE ID=5;


-- FOR TABLE AFTER INSERT TRIGGER
SET SERVEROUTPUT ON;
create or replace TRIGGER AI_VISIT_PROCESS
    AFTER INSERT
    ON VISIT_PROCESS1
DECLARE
    V_COUNT VISIT_PROCESS1.DIAGNOSIS_ID%TYPE;
BEGIN
    SELECT COUNT(DIAGNOSIS_ID) INTO V_COUNT FROM VISIT_PROCESS1 WHERE DIAGNOSIS_ID = 2;
    DBMS_OUTPUT.PUT_LINE('COVID-19 CASE FOR DAY ' || SYSDATE || ' : ' || V_COUNT);
END;
/
-- DML statements showing how above triggers work 
INSERT INTO VISIT_PROCESS1 (ID,VISIT_ID,SERVICE_ID,DIAGNOSIS_ID,PROCESS_DATE) VALUES
(5,3,2,2,NULL);
DELETE FROM VISIT_PROCESS1 WHERE ID=5;



-- FOR EACH ROW AFTER UPDATE TRIGGER
SET SERVEROUTPUT ON;
create or replace TRIGGER AU_SERVICE
    AFTER UPDATE
    ON SERVICE1
    FOR EACH ROW
DECLARE
    X INT;
    V_NAME SERVICE1.NAME%TYPE;
BEGIN
    X := :NEW.UNIT_PRICE - :OLD.UNIT_PRICE;
    V_NAME := :NEW.NAME;
    DBMS_OUTPUT.PUT_LINE(V_NAME || ' SERVICE UNIT PRICE IS UPDATED. %' || 100*X/:OLD.UNIT_PRICE || ' CHANGE IN UNIT PRICE IS APPLIED!');
END;
/
-- DML statements showing how above triggers work 
SELECT * FROM SERVICE;
UPDATE SERVICE1 SET UNIT_PRICE=30 WHERE ID = 1;




-- 1 BEFORE statement trigger (for INSERT, UPDATE and DELETE statements) (among them some table triggers, some row triggers)

-- FOR TABLE BEFORE DELETE TRIGGER
SET SERVEROUTPUT ON;
create or replace TRIGGER BD_PATIENT_COUNT
    BEFORE DELETE
    ON PATIENT1
DECLARE
    X INT;
BEGIN
    SELECT COUNT(ID) INTO X FROM PATIENT1;
    DBMS_OUTPUT.PUT_LINE('BEFORE DELETE ONE OF THE PATIENT WE HAD..:' || X || ' PATIENT');
END;
/
-- DML statements showing how above triggers work 
INSERT INTO PATIENT1 (ID,INSURANCE_ID,NAME,SURNAME,GENDER,BIRTHDATE,EMAIL,PHONE,DISTRICT,CITY) VALUES 
(5,1,'NEW','PERSON',NULL,NULL,NULL,NULL,NULL,NULL);
DELETE FROM PATIENT1 WHERE ID=5;

-- FOR EACH ROW BEFORE INSERT TRIGGER
create or replace TRIGGER BI_VISIT_PROCESS
BEFORE INSERT
ON VISIT_PROCESS1
FOR EACH ROW
DECLARE
    V_COUNT INT;
    PRICE INT;

BEGIN
    SELECT COUNT(VISIT_ID) INTO V_COUNT FROM VISIT_PROCESS1 WHERE VISIT_ID = :NEW.VISIT_ID;
    SELECT SUM(UNIT_PRICE*QUANTITY) INTO PRICE FROM SERVICE1 WHERE ID = :NEW.SERVICE_ID;
    IF V_COUNT > 0 THEN
        DBMS_OUTPUT.PUT_LINE('BEFORE INSERTING PROCESS FOR VISIT NUMBER..:' || :NEW.VISIT_ID || ', TOTAL COST IN SAME VISIT FROM PREVIOUS PROCESSES IS..:' || PRICE || 'PLN');
    ELSE
        DBMS_OUTPUT.PUT_LINE('THIS IS GOING TO BE THE FIRST PROCESS FOR VISIT NUMBER..: ' || :NEW.VISIT_ID);
    END IF;
END;
/
-- DML statements showing how above triggers work, also you can observe before insert and after insert statements together in this dml statement.
INSERT INTO VISIT_PROCESS1 (ID,VISIT_ID,SERVICE_ID,DIAGNOSIS_ID,PROCESS_DATE) VALUES
(5,4,3,2,NULL);
DELETE FROM VISIT_PROCESS1 WHERE ID=5;
-- dml to check else condition in trigger
INSERT INTO VISIT_PROCESS1 (ID,VISIT_ID,SERVICE_ID,DIAGNOSIS_ID,PROCESS_DATE) VALUES
(5,1,2,2,NULL);
DELETE FROM VISIT_PROCESS1 WHERE ID=5;



-- FOR EACH ROW BEFORE UPDATE TRIGGER
SET SERVEROUTPUT ON;
create or replace TRIGGER BU_DOCTOR_COMM
    BEFORE UPDATE
    ON DOCTOR1
    FOR EACH ROW
BEGIN

    IF :NEW.COMM IS NOT NULL THEN
        IF :NEW.COMM > :OLD.COMM THEN
            DBMS_OUTPUT.PUT_LINE('WELL DONE MR/MRS ' || :NEW.SURNAME || ', YOUR YEARLY COMMISION IS INCREASED BY..:' || (:NEW.COMM-:OLD.COMM) || 'PLN :)');
        ELSE 
            DBMS_OUTPUT.PUT_LINE('SORRY MR/MRS ' || :NEW.SURNAME || ', YOUR YEARLY COMMISION IS DECREASED BY..:' || (:NEW.COMM-:OLD.COMM) || 'PLN :( YOU HAVE TO TRY HARD!');
        END IF;
    ELSE
        DBMS_OUTPUT.PUT_LINE('WELL DONE MR/MRS ' || :NEW.SURNAME || ', HERE YOUR FIRST YEARLY COMMISION IS..:' || (:NEW.COMM) || 'PLN :)');
    END IF;
END;
/
-- DML statements showing how above triggers work 
SELECT * FROM DOCTOR1;
-- CASE 1
UPDATE DOCTOR1 SET COMM=2000 WHERE ID = 1;
-- CASE 2
UPDATE DOCTOR1 SET COMM=2000 WHERE ID = 2;
-- CASE 3
UPDATE DOCTOR1 SET COMM=2000 WHERE ID = 3;